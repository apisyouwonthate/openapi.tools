---
import type { GetStaticPaths } from 'astro';
import { getCollection, getEntry, render } from 'astro:content';

import { FilterableCollectionView } from '@/components/filters/FilterableCollectionView';
import PageHeader from '@/components/PageHeader.astro';
import Layout from '@/layouts/Layout.astro';
import PostHogLayout from '@/layouts/PostHogLayout.astro';
import {
  createBreadcrumbSchema,
  createCollectionPageSchema,
  serializeSchema,
} from '@/utils/structuredData';
import { isLegacy, isModern } from '@/utils/versionFilters';
import type { CollectionFilters } from '@/content.config';

// Helper function to filter tools based on collection filters
function filterTools(
  tools: Awaited<ReturnType<typeof getCollection<'tools'>>>,
  filters: CollectionFilters | undefined
) {
  if (!filters) return tools;

  return tools.filter((tool) => {
    // Legacy filter - show only legacy tools
    if (filters.legacy) {
      if (!isLegacy(tool.data)) return false;
    } else {
      // For non-legacy collections, only show modern tools
      if (!isModern(tool.data)) return false;
    }

    // Language filter
    if (filters.languages?.length) {
      const hasLang = filters.languages.some((l) => tool.data.languages?.[l]);
      if (!hasLang) return false;
    }

    // SaaS filter
    if (filters.saas && !tool.data.languages?.saas) return false;

    // Open source filter - must have repo URL
    if (filters.requireRepo && !tool.data.repo) return false;

    // Overlays filter
    if (filters.overlays && !tool.data.oaiSpecs?.overlays) return false;

    // Arazzo filter
    if (filters.arazzo && !tool.data.oaiSpecs?.arazzo) return false;

    // For non-arazzo/overlays collections, exclude tools where oaiSpecs.oas === false
    if (!filters.arazzo && !filters.overlays) {
      if (tool.data.oaiSpecs?.oas === false) return false;
    }

    // Version requirements
    if (filters.requireVersions?.length) {
      const hasVersion = filters.requireVersions.some(
        (v) => tool.data.oasVersions?.[v]
      );
      if (!hasVersion) return false;
    }

    // Badge requirements
    if (filters.requireBadges?.length) {
      const hasBadge = filters.requireBadges.some((badgeId) =>
        tool.data.badges?.some((badge) => badge.id === badgeId)
      );
      if (!hasBadge) return false;
    }

    return true;
  });
}

// 1. Generate a new path for every collection entry
export const getStaticPaths: GetStaticPaths = async () => {
  const curatedCollections = await getCollection('curated-collections');
  return curatedCollections.map((collection) => ({
    params: { slug: collection.id },
    props: { collection },
  }));
};

// 2. Get the collection from props
const { slug } = Astro.params;
const collection = await getEntry('curated-collections', slug as string);

if (!collection) {
  throw new Error(`No collection found for slug ${slug}`);
}

const { Content } = await render(collection);

// 3. Get all tools and filter them based on collection filters
const allTools = await getCollection('tools');
const filteredTools = filterTools(allTools, collection.data.filters);

// 4. Get all categories for grouping
const allCategories = await getCollection('categories');

// 5. Group filtered tools by category
type CategoryWithTools = {
  category: (typeof allCategories)[0];
  tools: typeof filteredTools;
};

const categoriesWithTools: CategoryWithTools[] = allCategories
  .map((category) => {
    const categoryIdWithoutExt = category.id.replace(/\.md$/, '');
    const toolsInCategory = filteredTools.filter((tool) =>
      tool.data.categories?.some((cat) => cat.id === categoryIdWithoutExt)
    );
    return {
      category,
      tools: toolsInCategory.sort((a, b) =>
        a.data.name.localeCompare(b.data.name)
      ),
    };
  })
  .filter((cat) => cat.tools.length > 0)
  .sort((a, b) => a.category.data.name.localeCompare(b.category.data.name));

const totalTools = filteredTools.length;

// Transform data for FilterableCollectionView
const categoryGroups = categoriesWithTools.map(({ category, tools }) => ({
  id: category.id,
  name: category.data.name,
  description: category.data.description,
  tools: tools.map((tool) => ({
    tool: tool.data,
    slug: tool.id,
    category: category.data,
  })),
}));
---

<PostHogLayout>
  <Layout
    title={collection.data.name}
    description={collection.data.description}
    ogImage={`https://openapi.tools/collections/${slug}.og.png`}
  >
    {/* Breadcrumb Structured Data */}
    <script
      is:inline
      slot="head"
      type="application/ld+json"
      set:html={serializeSchema(
        createBreadcrumbSchema([
          { name: 'Home', url: 'https://openapi.tools/' },
          { name: 'Collections', url: 'https://openapi.tools/' },
          {
            name: collection.data.name,
            url: `https://openapi.tools/collections/${slug}`,
          },
        ])
      )}
    />
    {/* CollectionPage Structured Data */}
    <script
      is:inline
      slot="head"
      type="application/ld+json"
      set:html={serializeSchema(
        createCollectionPageSchema({
          name: collection.data.name,
          description: collection.data.description,
          url: `https://openapi.tools/collections/${slug}`,
          tools: filteredTools.slice(0, 10).map((tool) => ({
            name: tool.data.name,
            url: `https://openapi.tools/tools/${tool.id}`,
          })),
        })
      )}
    />
    <PageHeader
      title={collection.data.name}
      description={collection.data.description}
    >
      <div
        class="prose prose-lg dark:prose-invert prose-headings:text-slate-700/90 dark:prose-headings:text-slate-300 mt-4"
      >
        <Content />
      </div>
    </PageHeader>

    <main class="w-full">
      <FilterableCollectionView
        client:only="react"
        categoriesWithTools={categoryGroups}
        totalToolCount={totalTools}
      />
    </main>
  </Layout>
</PostHogLayout>
