---
import type { GetStaticPaths } from 'astro';
import { getCollection, getEntry, render } from 'astro:content';

import { FilterableToolsList } from '@/components/filters/FilterableToolsList';
import Link from '@/components/Link';
import PageHeader from '@/components/PageHeader.astro';
import Layout from '@/layouts/Layout.astro';
import PostHogLayout from '@/layouts/PostHogLayout.astro';
import { isSponsorshipActive } from '@/utils/sponsorship';
import {
  createBreadcrumbSchema,
  createCollectionPageSchema,
  createFAQSchema,
  serializeSchema,
} from '@/utils/structuredData';
import { isModern } from '@/utils/versionFilters';

// 1. Generate a new path for every collection entry
export const getStaticPaths: GetStaticPaths = async () => {
  const categories = await getCollection('categories');
  return categories.map((category) => ({
    params: { slug: category.id },
    props: { category },
  }));
};

// 2. For your template, you can get the entry directly from the prop
const { slug } = Astro.params;
const category = await getEntry('categories', slug as string);

if (!category) {
  throw new Error(`No category found for slug ${slug}`);
}

const { Content } = await render(category);

// Note: category.id includes .md extension, but tool category references don't
const categoryIdWithoutExt = category.id.replace(/\.md$/, '');

// Track if there are legacy tools in this category
let hasLegacyTools = false;

const allTools = (await getCollection('tools')).filter((tool) => {
  if (!tool.data.categories) {
    return false;
  }
  // Exclude tools where oaiSpecs.oas === false (non-OAS tools)
  if (tool.data.oaiSpecs?.oas === false) {
    return false;
  }
  const categories = tool.data.categories;
  // Check if tool belongs to this category
  const isInCategory = categories.some(
    (cat) => cat.id === categoryIdWithoutExt
  );

  if (!isInCategory) {
    return false;
  }

  // Only show tools that support modern OpenAPI versions
  if (!isModern(tool.data)) {
    // Yep we found some old stuff
    hasLegacyTools = true;
    return false;
  }

  return true;
});

// get all the actively sponsored tools
const sponsoredTools = allTools
  .filter((tool) => isSponsorshipActive(tool.data))
  .sort((a, b) => {
    // sort sponsored tools by start date
    const aDate = new Date(a.data.sponsorship![0].startDate);
    const bDate = new Date(b.data.sponsorship![0].startDate);
    return aDate.getTime() - bDate.getTime();
  });

// get all the tools that are not actively sponsored
const nonSponsoredTools = allTools
  .filter((tool) => !isSponsorshipActive(tool.data))
  .sort((a, b) => {
    return a.data.name.localeCompare(b.data.name);
  });

const tools = [...sponsoredTools, ...nonSponsoredTools];
const toolsData = tools.map((tool) => ({
  category: category.data,
  tool: tool.data,
  slug: tool.id,
}));
---

<PostHogLayout>
  <Layout
    title={category.data.name}
    description={category.data.description}
    ogImage={`https://openapi.tools/categories/${slug}.og.png`}
  >
    {/* Breadcrumb Structured Data */}
    <script
      is:inline
      slot="head"
      type="application/ld+json"
      set:html={serializeSchema(
        createBreadcrumbSchema([
          { name: 'Home', url: 'https://openapi.tools/' },
          { name: 'Categories', url: 'https://openapi.tools/' },
          {
            name: category.data.name,
            url: `https://openapi.tools/categories/${slug}`,
          },
        ])
      )}
    />
    {/* CollectionPage Structured Data */}
    <script
      is:inline
      slot="head"
      type="application/ld+json"
      set:html={serializeSchema(
        createCollectionPageSchema({
          name: category.data.name,
          description: category.data.description,
          url: `https://openapi.tools/categories/${slug}`,
          tools: tools.map((t) => ({
            name: t.data.name,
            url: `https://openapi.tools/tools/${t.id}`,
          })),
        })
      )}
    />
    {/* FAQ Structured Data */}
    <script
      is:inline
      slot="head"
      type="application/ld+json"
      set:html={serializeSchema(
        createFAQSchema([
          {
            question: `What are the best ${category.data.name.toLowerCase()} for OpenAPI?`,
            answer: `OpenAPI.tools lists ${tools.length} ${category.data.name.toLowerCase()}. ${
              tools.length > 0
                ? `Popular options include ${tools
                    .slice(0, 3)
                    .map((t) => t.data.name)
                    .join(', ')}.`
                : ''
            } Browse the full list to find the best fit for your needs.`,
          },
          {
            question: `Are there free ${category.data.name.toLowerCase()} for OpenAPI?`,
            answer: `Yes, many ${category.data.name.toLowerCase()} on OpenAPI.tools are free and open source. Look for tools with a repository link to find open source options.`,
          },
          {
            question: `Which ${category.data.name.toLowerCase()} support OpenAPI 3.1?`,
            answer: `OpenAPI.tools shows version support for each tool. Use the filters to find ${category.data.name.toLowerCase()} that support OpenAPI 3.1 or any other version you need.`,
          },
        ])
      )}
    />

    <PageHeader
      title={category.data.name}
      description={category.data.description}
    >
      {/* render the body of the markdown file for this category */}
      <div
        class="prose prose-lg dark:prose-invert prose-headings:text-slate-700/90 dark:prose-headings:text-slate-300"
      >
        <Content />
      </div>
    </PageHeader>

    <main
      class="prose-lg dark:prose-invert prose-headings:text-slate-700/90 dark:prose-headings:text-slate-300 w-full"
    >
      <h2 class="prose mb-4 text-2xl font-bold">
        {category.data.name}
      </h2>
      <section class="prose w-full max-w-none">
        <FilterableToolsList client:only="react" tools={toolsData} />
      </section>

      {
        hasLegacyTools && (
          <div class="mt-8 rounded-lg border border-slate-200 bg-slate-50 p-4 dark:border-slate-700 dark:bg-slate-800/50">
            <p class="m-0 text-slate-700 dark:text-slate-300">
              There are additional tools in this category, but they only support
              legacy versions of OpenAPI. If you really need to work with some
              old OpenAPI descriptions perhaps
              <Link
                href={`/legacy#${slug}`}
                className="text-emerald-600 hover:text-emerald-700 dark:text-emerald-400 dark:hover:text-emerald-300 font-medium"
              >
                these legacy tools
              </Link>
              could be of use
            </p>
          </div>
        )
      }
    </main>
  </Layout>
</PostHogLayout>
